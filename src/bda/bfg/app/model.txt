Application Model
=================

The application model is used to describe the application hierarchy, fetch
application specific information and access application data.

The base application node inherits from ``zodict.node.LifecycleNode``. This
has some advantages:

    - ``repoze.bfg`` expects dict like objects for traversal, so we already
      fulfill this contract by using Nodes.
    
    - It is ordered.
    
    - Nodes know about it's location so we can easily generate URL's out of
      ``Node.path``.
    
    - The model is held in memory. ``LifecycleNode`` triggers object events
      when it is modified, so we can subscribe to this events for data or tree
      manipulation or trigger those events ourself, i.e. on cache timeouts.
    
    - Nodes have an index holding references to all contained Nodes in the tree
      by uid. This makes it easy to access information from other Nodes in the
      tree.

``bda.bfg.app.interfaces.IApplicationNode`` extend this interface by:

    - An ``__acl__`` property defining security. See documentation of
      ``repoze.bfg.security`` for details.
    
    - A ``properties`` property, containing IProperties implementing object.
    
    - A ``metadata`` property, containing IMetadata implementing object.
    
    - A ``nodeinfo`` property containing INodeInfo implementing object.


BaseNode
--------
::

    >>> from bda.bfg.app.model import BaseNode
    >>> root = BaseNode()

Default permissions.
::

    >>> root.__acl__
    [('Allow', 'group:authenticated', 'view'), 
    ('Allow', 'system.Everyone', 'login'), 
    ('Deny', 'system.Everyone', 
    <repoze.bfg.security.AllPermissionsList object at ...>)]

Properties.
::

    >>> root.properties
    <bda.bfg.app.model.Properties object at ...>

Metadata.
::

    >>> root.metadata
    <bda.bfg.app.model.BaseMetadata object at ...>
    
    >>> root.metadata.title
    'No Title'

``IMetadata`` implementations do not raise AttributeErrors if requested metadata
not exists.
::

    >>> root.metadata.inexistent

Nodeinfo.
::

    >>> root.nodeinfo
    <bda.bfg.app.model.BaseNodeInfo object at ...>
    
    >>> root.nodeinfo.node
    <class 'bda.bfg.app.model.BaseNode'>
    
    >>> root.nodeinfo.title
    "<class 'bda.bfg.app.model.BaseNode'>"


FactoryNode
-----------

You can use the factory node to build static structures. It created the child
Node for ``key`` on ``__getitem__`` if not existent yet.
::

    >>> from bda.bfg.app.model import FactoryNode
    >>> class Root(FactoryNode):
    ...     factories = {
    ...         'foo': BaseNode,
    ...         'bar': BaseNode,
    ...     }
    
    >>> root = Root()
    >>> root['foo']
    <BaseNode object 'foo' at ...>
    
    >>> root['bar']
    <BaseNode object 'bar' at ...>
    
    >>> root['baz']
    Traceback (most recent call last):
      ...
    KeyError


AdapterNode
-----------

An AdapterNode is intended to be used if you want to publish some kind of dict
like object or other node implementations.

Since other node implementations depend on its own internal hierarchy and
do not provide the extensions described in
``bda.bfg.app.interfaces.IApplicationNode``, we have to wrap it inside a
adapter node in order to use it inside the application.

The adapter node calls for common read operations the equivalent functions on
it's adapted model.
::

    >>> from zodict.node import AttributedNode
    >>> from bda.bfg.app.model import AdapterNode
    
    >>> toadapt = AttributedNode()
    >>> toadapt['foo'] = AttributedNode()
    >>> toadapt['bar'] = AttributedNode()
    >>> toadapt.attrs.title = 'Some title'
    >>> toadapt.attrs.description = 'Some description'

Adapt created node structure.
::

    >>> adapter = AdapterNode(toadapt, 'name', None)

Check ``AdapterNode`` interface.

``__getitem__``
::

    >>> adapter['foo']
    <AttributedNode object 'foo' at ...>

``__contains__``
::

    >>> 'bar' in adapter
    True

``__len__``
::

    >>> len(adapter)
    2

``__iter__``
::

    >>> [key for key in adapter]
    ['foo', 'bar']

``keys``
::

    >>> adapter.keys()
    ['foo', 'bar']

``values``
::

    >>> adapter.values()
    [<AttributedNode object 'foo' at ...>, 
    <AttributedNode object 'bar' at ...>]

``items``
::

    >>> adapter.items()
    [('foo', <AttributedNode object 'foo' at ...>), 
    ('bar', <AttributedNode object 'bar' at ...>)]

``get``
::

    >>> adapter.get('bar')
    <AttributedNode object 'bar' at ...>

``attrs``
::

    >>> adapter.attrs.title
    'Some title'
    
The adapter node is responsible to return other adapters nodes or application
nodes on ``__getitem__`` if application hierarchy continues.

You can do key aliasing as well at this place.
::

    >>> class MyAdapterNode(AdapterNode):
    ...     def __getitem__(self, key):
    ...         return AdapterNode(self.model['bar'], key, self)

This dummy class does a static mapping on __getitem__.
::

    >>> node = MyAdapterNode(toadapt, 'adapter', None)
    >>> child = node['aliased']
    >>> child
    <AdapterNode object 'aliased' at ...>
    
    >>> child.model
    <AttributedNode object 'bar' at ...>

The application node path differs from the adapted node path. This is essential
to keep the application path sane while not violating the adapted node's
structure.
::

    >>> child.path
    ['adapter', 'aliased']
    
    >>> child.model.path
    [None, 'bar']


Metadata
--------

The ``IMetadata`` implementation returned by ``IApplicationNode.metadata`` is
used by the application for displaying metadata information.

The default implementation accepts a dict like object on ``__init__``.
::

    >>> from bda.bfg.app.model import BaseMetadata
    >>> data = {
    ...     'title': 'some title',
    ...     'description': 'some description',
    ...     'creator': 'john doe',
    ... }

Check ``INodeAdapter`` interface.
::

    >>> metadata = BaseMetadata(data)

``__getattr__``. No AttributeError is raised if attribute is inexistent.
::

    >>> metadata.title
    'some title'
    
    >>> metadata.description
    'some description'
    
    >>> metadata.creator
    'john doe'
    
    >>> metadata.inexistent

``__getitem__``
::

    >>> metadata['title']
    'some title'

``__contains__``
::

    >>> 'description' in metadata
    True

``get``
::

    >>> metadata.get('creator')
    'john doe'

NodeInfo
--------

The ``INodeInfo`` providing object holds information about the application node.
::

    >>> from bda.bfg.app.model import BaseNodeInfo
    >>> nodeinfo = BaseNodeInfo()
    >>> nodeinfo.node = BaseNode
    >>> nodeinfo.addables = ['basenode']
    >>> nodeinfo.title = 'Base Node'

Register node info.
::

    >>> from bda.bfg.app.model import registerNodeInfo, getNodeInfo
    >>> registerNodeInfo('basenode', nodeinfo)

Lookup Node info.
::

    >>> nodeinfo = getNodeInfo('basenode')
    >>> nodeinfo.title
    'Base Node'

``__getattr__``. No AttributeError is raised if attribute is inexistent.
::

    >>> nodeinfo.addables
    ['basenode']
    
    >>> nodeinfo.inexistent

``__getitem__``
::

    >>> nodeinfo['addables']
    ['basenode']

``__contains__``
::

    >>> 'node' in nodeinfo
    True

``get``
::

    >>> nodeinfo.get('node')
    <class 'bda.bfg.app.model.BaseNode'>


Properties
----------

You can use the ``Properties`` object for any kind of mapping.
::

    >>> from bda.bfg.app.model import Properties
    >>> p1 = Properties()
    >>> p1.prop = 'Foo'
    
    >>> p2 = Properties()
    >>> p2.prop = 'Bar'
    
    >>> p1.prop, p2.prop
    ('Foo', 'Bar')